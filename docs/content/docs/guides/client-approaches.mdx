---
title: Client-Side Approaches
description: Compare the structured client vs hook-based approaches for file uploads
---

import { Callout } from "fumadocs-ui/components/callout";
import { Card, Cards } from "fumadocs-ui/components/card";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

## Client-Side Approaches

Pushduck provides **two ways** to integrate file uploads in your React components. Both approaches now provide **identical functionality** including per-route callbacks, progress tracking, and error handling.

<Callout type="success">
  **Recommendation**: Use the **Enhanced Structured Client** approach for the best developer experience. It now provides the same flexibility as hooks while maintaining superior type safety and centralized configuration.
</Callout>

## Quick Comparison

<Cards>
  <Card
    title="üèÜ Enhanced Structured Client (Recommended)"
    description="Property-based access with optional per-route configuration"
  >
    ```typescript
    const upload = createUploadClient<AppRouter>({
      endpoint: '/api/upload'
    })
    
    // Simple usage
    const { uploadFiles, files } = upload.imageUpload()
    
    // With per-route callbacks (NEW!)
    const { uploadFiles, files } = upload.imageUpload({
      onStart: (files) => setUploadStarted(true),
      onSuccess: (results) => handleSuccess(results),
      onError: (error) => handleError(error),
      onProgress: (progress) => setProgress(progress)
    })
    ```
    
    **Best for**: Most projects - provides superior DX, type safety, and full flexibility
  </Card>

  <Card
    title="ü™ù Hook-Based"
    description="Traditional React hook pattern"
  >
    ```typescript
    const { uploadFiles, files } = useUploadRoute<AppRouter>('imageUpload', {
      onStart: (files) => setUploadStarted(true),
      onSuccess: (results) => handleSuccess(results),
      onError: (error) => handleError(error),
      onProgress: (progress) => setProgress(progress)
    })
    ```
    
    **Best for**: Teams that strongly prefer React hooks, legacy code migration
  </Card>
</Cards>

## Feature Parity

Both approaches now support **identical functionality**:

| Feature | Enhanced Structured Client | Hook-Based |
|---------|---------------------------|------------|
| ‚úÖ Type Safety | **Superior** - Property-based | Good - Generic types |
| ‚úÖ Per-route Callbacks | **‚úÖ Full support** | ‚úÖ Full support |
| ‚úÖ Progress Tracking | **‚úÖ Full support** | ‚úÖ Full support |
| ‚úÖ Error Handling | **‚úÖ Full support** | ‚úÖ Full support |
| ‚úÖ Multiple Endpoints | **‚úÖ Per-route endpoints** | ‚úÖ Per-route endpoints |
| ‚úÖ Upload Control | **‚úÖ Enable/disable uploads** | ‚úÖ Enable/disable uploads |
| ‚úÖ Auto-upload | **‚úÖ Per-route control** | ‚úÖ Per-route control |
| ‚úÖ Overall Progress | **‚úÖ progress, uploadSpeed, eta** | ‚úÖ progress, uploadSpeed, eta |

## API Comparison: Identical Capabilities

Both approaches now return **exactly the same** properties and accept **exactly the same** configuration options:

```typescript
// Hook-Based Approach
const {
  uploadFiles,    // (files: File[]) => Promise<void>
  files,          // S3UploadedFile[]
  isUploading,    // boolean
  errors,         // string[]
  reset,          // () => void
  progress,       // number (0-100) - overall progress
  uploadSpeed,    // number (bytes/sec) - overall speed
  eta             // number (seconds) - overall ETA
} = useUploadRoute<AppRouter>('imageUpload', {
  onStart: (files) => setUploadStarted(true),
  onSuccess: (results) => handleSuccess(results),
  onError: (error) => handleError(error),
  onProgress: (progress) => setProgress(progress),
  endpoint: '/api/custom-upload',
  disabled: false,
  autoUpload: true
});

// Enhanced Structured Client - IDENTICAL capabilities
const {
  uploadFiles,    // (files: File[]) => Promise<void>
  files,          // S3UploadedFile[]
  isUploading,    // boolean
  errors,         // string[]
  reset,          // () => void
  progress,       // number (0-100) - overall progress
  uploadSpeed,    // number (bytes/sec) - overall speed
  eta             // number (seconds) - overall ETA
} = upload.imageUpload({
  onStart: (files) => setUploadStarted(true),
  onSuccess: (results) => handleSuccess(results),
  onError: (error) => handleError(error),
  onProgress: (progress) => setProgress(progress),
  endpoint: '/api/custom-upload',
  disabled: false,
  autoUpload: true
});
```

## Complete Options Parity

Both approaches support **identical configuration options**:

```typescript
interface CommonUploadOptions {
  onStart?: (files: S3FileMetadata[]) => void;
  onSuccess?: (results: UploadResult[]) => void;
  onError?: (error: Error) => void;
  onProgress?: (progress: number) => void;
  endpoint?: string;           // Custom endpoint per route
  disabled?: boolean;          // Enable/disable uploads
  autoUpload?: boolean;        // Auto-upload when files selected
}

// Hook-based: useUploadRoute(routeName, options)
// Structured: upload.routeName(options)
// Both accept the same CommonUploadOptions interface
```

## Return Value Parity

Both approaches return **identical properties**:

```typescript
interface CommonUploadReturn {
  uploadFiles: (files: File[]) => Promise<void>;
  files: S3UploadedFile[];
  isUploading: boolean;
  errors: string[];
  reset: () => void;
  
  // Overall progress tracking (NEW in both!)
  progress?: number;     // 0-100 percentage across all files
  uploadSpeed?: number;  // bytes per second across all files  
  eta?: number;          // seconds remaining for all files
}
```

## Enhanced Structured Client Examples

### Basic Usage (Unchanged)

```typescript
import { createUploadClient } from 'pushduck/client'
import type { AppRouter } from '@/lib/upload'

const upload = createUploadClient<AppRouter>({ endpoint: '/api/upload' })

export function SimpleUpload() {
  const { uploadFiles, files, isUploading } = upload.imageUpload()
  
  return (
    <input 
      type="file" 
      onChange={(e) => uploadFiles(Array.from(e.target.files || []))}
      disabled={isUploading}
    />
  )
}
```

### With Per-Route Configuration (NEW!)

```typescript
export function AdvancedUpload() {
  const [progress, setProgress] = useState(0)
  
  const { uploadFiles, files, isUploading, errors, reset } = 
    upload.imageUpload({
      onStart: (files) => {
        console.log('üöÄ Upload starting!', files)
        setUploadStarted(true)
      },
      onSuccess: (results) => {
        console.log('‚úÖ Upload successful!', results)
        showNotification('Images uploaded successfully!')
        setUploadStarted(false)
      },
      onError: (error) => {
        console.error('‚ùå Upload failed:', error)
        showErrorNotification(error.message)
        setUploadStarted(false)
      },
      onProgress: (progress) => {
        console.log(`üìä Progress: ${progress}%`)
        setProgress(progress)
      }
    })

  return (
    <div>
      <input type="file" onChange={(e) => uploadFiles(Array.from(e.target.files || []))} />
      {progress > 0 && <progress value={progress} max={100} />}
      <button onClick={reset}>Reset</button>
    </div>
  )
}
```

### Multiple Routes with Different Configurations

```typescript
export function MultiUploadComponent() {
  // Images with progress tracking
  const images = upload.imageUpload({
    onStart: (files) => setUploadingImages(true),
    onProgress: (progress) => setImageProgress(progress)
  })
  
  // Documents with different endpoint and success handler
  const documents = upload.documentUpload({
    endpoint: '/api/secure-upload',
    onStart: (files) => setUploadingDocuments(true),
    onSuccess: (results) => updateDocumentLibrary(results)
  })
  
  // Videos with upload disabled (feature flag)
  const videos = upload.videoUpload({
    disabled: !isVideoUploadEnabled,
    onStart: (files) => setUploadingVideos(true)
  })

  return (
    <div>
      <FileUploadSection {...images} accept="image/*" />
      <FileUploadSection {...documents} accept=".pdf,.doc" />
      <FileUploadSection {...videos} accept="video/*" />
    </div>
  )
}
```

### Global Configuration with Per-Route Overrides

```typescript
const upload = createUploadClient<AppRouter>({
  endpoint: '/api/upload',
  
  // Global defaults (optional)
  defaultOptions: {
    onStart: (files) => console.log(`Starting upload of ${files.length} files`),
    onProgress: (progress) => console.log(`Global progress: ${progress}%`),
    onError: (error) => logError(error)
  }
})

// This route inherits global defaults
const basic = upload.imageUpload()

// This route overrides specific options
const custom = upload.documentUpload({
  endpoint: '/api/secure-upload', // Override endpoint
  onSuccess: (results) => handleSecureUpload(results) // Add success handler
  // Still inherits global onProgress and onError
})
```

## Hook-Based Approach (Unchanged)

```typescript
import { useUploadRoute } from 'pushduck/client'

export function HookBasedUpload() {
  const { uploadFiles, files, isUploading, error } = useUploadRoute<AppRouter>('imageUpload', {
    onStart: (files) => console.log('Starting upload:', files),
    onSuccess: (results) => console.log('Success:', results),
    onError: (error) => console.error('Error:', error),
    onProgress: (progress) => console.log('Progress:', progress)
  })

  return (
    <input 
      type="file" 
      onChange={(e) => uploadFiles(Array.from(e.target.files || []))}
      disabled={isUploading}
    />
  )
}
```

## Migration Guide

### From Hook-Based to Enhanced Structured Client

```typescript
// Before: Hook-based
const { uploadFiles, files } = useUploadRoute<AppRouter>('imageUpload', {
  onStart: handleStart,
  onSuccess: handleSuccess,
  onError: handleError
})

// After: Enhanced structured client
const upload = createUploadClient<AppRouter>({ endpoint: '/api/upload' })
const { uploadFiles, files } = upload.imageUpload({
  onStart: handleStart,
  onSuccess: handleSuccess,
  onError: handleError
})
```

### Benefits of Migration

1. **Better Type Safety**: Route names are validated at compile time
2. **Enhanced IntelliSense**: Auto-completion for all available routes
3. **Centralized Configuration**: Single place to configure endpoints and defaults
4. **Refactoring Support**: Rename routes safely across your codebase
5. **No Performance Impact**: Same underlying implementation

## When to Use Each Approach

### Use Enhanced Structured Client When:
- ‚úÖ **Starting a new project** - best overall developer experience
- ‚úÖ **Want superior type safety** - compile-time route validation
- ‚úÖ **Need centralized configuration** - single place for settings
- ‚úÖ **Value refactoring support** - safe route renames

### Use Hook-Based When:
- ‚úÖ **Migrating existing code** - minimal changes required
- ‚úÖ **Dynamic route names** - routes determined at runtime
- ‚úÖ **Team strongly prefers hooks** - familiar React patterns
- ‚úÖ **Legacy compatibility** - maintaining older codebases

## Performance Considerations

Both approaches have **identical performance** characteristics:
- Same underlying `useUploadRoute` implementation
- Same network requests and upload logic
- Same React hooks rules and lifecycle

The enhanced structured client adds zero runtime overhead while providing compile-time benefits.

---

<Callout type="info">
  **Full Feature Parity**: Both approaches now support the same functionality. The choice comes down to developer experience preferences rather than feature limitations.
</Callout>

## Detailed Comparison

### Type Safety & Developer Experience

<Tabs items={["Structured Client", "Hook-Based"]}>
  <Tab value="Structured Client">
    ```typescript
    // ‚úÖ Complete type inference from server router
    const upload = createUploadClient<AppRouter>({
      endpoint: '/api/upload'
    })
    
    // ‚úÖ Property-based access - no string literals
    const { uploadFiles, files } = upload.imageUpload()
    
    // ‚úÖ IntelliSense shows all available endpoints
    upload. // <- Shows: imageUpload, documentUpload, videoUpload...
    
    // ‚úÖ Compile-time validation
    upload.nonExistentRoute() // ‚ùå TypeScript error
    
    // ‚úÖ Refactoring safety
    // Rename routes in router ‚Üí TypeScript shows all usage locations
    ```
    
    **Benefits:**
    - üéØ **Full type inference** from server to client
    - üîç **IntelliSense support** - discover endpoints through IDE
    - üõ°Ô∏è **Refactoring safety** - rename with confidence
    - üö´ **No string literals** - eliminates typos
    - ‚ö° **Better DX** - property-based access feels natural
  </Tab>
  
     <Tab value="Hook-Based">
     ```typescript
     // ‚úÖ With type parameter - recommended for better type safety
     const { uploadFiles, files } = useUploadRoute<AppRouter>('imageUpload')
     
     // ‚úÖ Without type parameter - also works
     const { uploadFiles, files } = useUploadRoute('imageUpload')
     
     // Type parameter provides compile-time validation
     const typed = useUploadRoute<AppRouter>('imageUpload') // Route validated
     const untyped = useUploadRoute('imageUpload') // Any string accepted
     ```
     
     **Characteristics:**
     - ü™ù **React hook pattern** - familiar to React developers
     - üî§ **Flexible usage** - works with or without type parameter
     - üß© **Component-level state** - each hook manages its own state
     - üéØ **Type safety** - enhanced when using `<AppRouter>`
     - üîç **IDE support** - best with type parameter
   </Tab>
</Tabs>

### Code Examples

<Tabs items={["Image Uploader", "Multiple Routes", "With Authentication"]}>
  <Tab value="Image Uploader">
    **Structured Client:**
    ```typescript
    import { upload } from '@/lib/upload-client'
    
    export function ImageUploader() {
      const { uploadFiles, files, isUploading, error } = upload.imageUpload()
      
      return (
        <div>
          <input 
            type="file" 
            onChange={(e) => uploadFiles(Array.from(e.target.files || []))}
            disabled={isUploading}
          />
          {/* Upload UI */}
        </div>
      )
    }
    ```
    
         **Hook-Based:**
     ```typescript
     import { useUploadRoute } from 'pushduck/client'
     
     export function ImageUploader() {
       const { uploadFiles, files, isUploading, error } = useUploadRoute<AppRouter>('imageUpload')
      
      return (
        <div>
          <input 
            type="file" 
            onChange={(e) => uploadFiles(Array.from(e.target.files || []))}
            disabled={isUploading}
          />
          {/* Same upload UI */}
        </div>
      )
    }
    ```
  </Tab>
  
  <Tab value="Multiple Routes">
    **Structured Client:**
    ```typescript
    export function FileManager() {
      const images = upload.imageUpload()
      const documents = upload.documentUpload()
      const videos = upload.videoUpload()
      
      return (
        <div>
          <ImageSection {...images} />
          <DocumentSection {...documents} />
          <VideoSection {...videos} />
        </div>
      )
    }
    ```
    
         **Hook-Based:**
     ```typescript
     export function FileManager() {
       const images = useUploadRoute<AppRouter>('imageUpload')
       const documents = useUploadRoute<AppRouter>('documentUpload')
       const videos = useUploadRoute<AppRouter>('videoUpload')
      
      return (
        <div>
          <ImageSection {...images} />
          <DocumentSection {...documents} />
          <VideoSection {...videos} />
        </div>
      )
    }
    ```
  </Tab>
  
  <Tab value="With Authentication">
    **Structured Client:**
    ```typescript
    // lib/upload-client.ts
    export const upload = createUploadClient<AppRouter>({
      endpoint: '/api/upload',
      headers: {
        Authorization: `Bearer ${getAuthToken()}`
      }
    })
    
    // components/secure-uploader.tsx
    export function SecureUploader() {
      const { uploadFiles } = upload.secureUpload()
      // Authentication handled globally
    }
    ```
    
         **Hook-Based:**
     ```typescript
     export function SecureUploader() {
       const { uploadFiles } = useUploadRoute<AppRouter>('secureUpload', {
         headers: {
           Authorization: `Bearer ${getAuthToken()}`
         }
       })
       // Authentication per hook usage
     }
    ```
  </Tab>
</Tabs>

## Conclusion

<Callout type="success">
  **Our Recommendation**: Use the **Enhanced Structured Client** approach (`createUploadClient`) for most projects. It provides superior developer experience, better refactoring safety, and enhanced type inference.
</Callout>

<Callout type="info">
  **Both approaches are supported**: The hook-based approach (`useUploadRoute<AppRouter>`) is fully supported and valid for teams that prefer traditional React patterns.
</Callout>

**Quick Decision Guide:**
- **Most projects** ‚Üí Use `createUploadClient` (recommended)
- **Strongly prefer React hooks** ‚Üí Use `useUploadRoute<AppRouter>`
- **Want best DX and type safety** ‚Üí Use `createUploadClient`
- **Need component-level control** ‚Üí Use `useUploadRoute<AppRouter>`

### Next Steps

- **New Project**: Start with [createUploadClient](/docs/api/utilities/create-upload-client)
- **Existing Hook Code**: Consider [migrating gradually](/docs/guides/migration/enhanced-client)
- **Need Help**: Join our [Discord community](https://pushduck.dev/discord) for guidance 