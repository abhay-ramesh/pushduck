---
title: Server Router Configuration
description: Complete guide to configuring your upload router with type safety and advanced features
---

import { Callout } from "fumadocs-ui/components/callout";
import { Card, Cards } from "fumadocs-ui/components/card";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";
import { File, Folder, Files } from "fumadocs-ui/components/files";
import { TypeTable } from "fumadocs-ui/components/type-table";

# Server Router Configuration

The server router is the heart of next-s3-uploader. It defines your upload endpoints with complete type safety and validates all uploads against your schema.

<Callout type="info">
  This guide covers the **enhanced router API** with property-based client
  access. Looking for the legacy API? Check our [migration
  guide](/docs/guides/migration/enhanced-client).
</Callout>

## Project Structure

A typical Next.js project with next-s3-uploader follows this structure:

<Files>
  <Folder name="your-app" defaultOpen>
    <Folder name="app">
      <Folder name="api">
        <Folder name="upload" defaultOpen>
          <File name="route.ts" />
        </Folder>
      </Folder>
      <File name="layout.tsx" />
      <File name="page.tsx" />
    </Folder>
    <Folder name="lib">
      <File name="upload.ts" />
      <File name="upload-client.ts" />
    </Folder>
    <File name=".env.local" />
    <File name="next.config.js" />
  </Folder>
</Files>

## Basic Router Setup

<Steps>
  <Step>
    **Create your upload route**
    
    Start by creating the API route that will handle your uploads:

    ```typescript title="app/api/upload/route.ts"
    import { createUploadRouter, uploadSchema } from 'next-s3-uploader/server'
    import { createS3Client } from 'next-s3-uploader/s3'

    const s3 = createS3Client({
      endpoint: process.env.S3_ENDPOINT!,
      accessKeyId: process.env.S3_ACCESS_KEY_ID!,
      secretAccessKey: process.env.S3_SECRET_ACCESS_KEY!,
      bucket: process.env.S3_BUCKET!,
      region: process.env.S3_REGION!,
    })

    export const { POST, GET } = createUploadRouter({
      imageUpload: uploadSchema({
        image: {
          maxSize: "4MB",
          maxCount: 10,
        }
      }).middleware(({ req }) => {
        // Add your authentication logic here
        return { userId: "user_123" }
      }),

      documentUpload: uploadSchema({
        pdf: {
          maxSize: "10MB",
          maxCount: 1,
        }
      })
    }, { s3 })
    ```

  </Step>

  <Step>
    **Export router types**
    
    Create a separate file to export your router types for client-side usage:

    ```typescript title="lib/upload.ts"
    import { createUploadRouter, uploadSchema } from 'next-s3-uploader/server'

    // Define your router (same as in route.ts)
    export const router = createUploadRouter({
      imageUpload: uploadSchema({
        image: { maxSize: "4MB", maxCount: 10 }
      }),
      documentUpload: uploadSchema({
        pdf: { maxSize: "10MB", maxCount: 1 }
      })
    })

    // Export the router type for client usage
    export type AppRouter = typeof router
    ```

  </Step>

  <Step>
    **Create typed client**
    
    Set up your client-side upload client with full type safety:

    ```typescript title="lib/upload-client.ts"
    import { createUploadClient } from 'next-s3-uploader/client'
    import type { AppRouter } from './upload'

    export const upload = createUploadClient<AppRouter>({
      endpoint: '/api/upload'
    })
    ```

  </Step>
</Steps>

## Schema Builder Reference

The `uploadSchema` function provides a fluent API for defining your upload requirements:

<TypeTable
  type={{
    image: {
      description: "Image file validation and processing options",
      type: "FileConfig",
    },
    video: {
      description: "Video file validation and processing options",
      type: "FileConfig",
    },
    pdf: {
      description: "PDF file validation options",
      type: "FileConfig",
    },
    any: {
      description: "Accept any file type with size/count limits",
      type: "FileConfig",
    },
  }}
/>

### FileConfig Options

<TypeTable
  type={{
    maxSize: {
      description: 'Maximum file size (e.g., "4MB", "1GB")',
      type: "string",
      default: '"1MB"',
    },
    maxCount: {
      description: "Maximum number of files that can be uploaded",
      type: "number",
      default: "1",
    },
    mimeTypes: {
      description:
        "Allowed MIME types. Auto-detected from file type if not specified",
      type: "string[]",
    },
    processing: {
      description: "File processing options (resize, format conversion, etc.)",
      type: "ProcessingConfig",
    },
  }}
/>

## Advanced Configuration

### Multiple File Types

You can define schemas that accept multiple file types:

<Tabs items={["Images & Documents", "Mixed Media", "Any Files"]} groupId="file-types">
  <Tab value="Images & Documents">
    ```typescript
    export const router = createUploadRouter({
      mixedUpload: uploadSchema({
        image: { maxSize: "4MB", maxCount: 5 },
        pdf: { maxSize: "10MB", maxCount: 2 },
        docx: { maxSize: "5MB", maxCount: 3 }
      })
    })
    ```
  </Tab>
  
  <Tab value="Mixed Media">
    ```typescript
    export const router = createUploadRouter({
      mediaUpload: uploadSchema({
        image: { 
          maxSize: "4MB", 
          maxCount: 10,
          processing: {
            resize: { width: 1200, height: 1200 },
            format: "webp"
          }
        },
        video: { 
          maxSize: "100MB", 
          maxCount: 2,
          processing: {
            transcode: { format: "mp4", quality: "720p" }
          }
        }
      })
    })
    ```
  </Tab>
  
  <Tab value="Any Files">
    ```typescript
    export const router = createUploadRouter({
      genericUpload: uploadSchema({
        any: { 
          maxSize: "50MB", 
          maxCount: 20,
          mimeTypes: [
            "image/*", "video/*", "application/pdf", 
            "application/msword", "text/plain"
          ]
        }
      })
    })
    ```
  </Tab>
</Tabs>

### Global Configuration

Configure settings that apply to all upload endpoints:

<TypeTable
  type={{
    maxTotalSize: {
      description: "Maximum total size across all files in a single upload",
      type: "string",
      default: '"100MB"',
    },
    allowedOrigins: {
      description: "CORS origins allowed to upload",
      type: "string[]",
      default: '["*"]',
    },
    uploadTimeout: {
      description: "Maximum time allowed for upload completion",
      type: "number",
      default: "300000",
    },
    pathPrefix: {
      description: "S3 key prefix for all uploaded files",
      type: "string",
    },
  }}
/>

```typescript
export const { POST, GET } = createUploadRouter(
  {
    // ... your upload schemas
  },
  {
    s3,
    maxTotalSize: "500MB",
    allowedOrigins: ["https://yourdomain.com"],
    uploadTimeout: 600000, // 10 minutes
    pathPrefix: "uploads/",
  }
);
```

### Multiple Providers

Support different storage providers for different upload types:

```typescript
import { createS3Client } from "next-s3-uploader/s3";

const primaryS3 = createS3Client({
  // Primary S3 config for production files
});

const backupR2 = createS3Client({
  // Cloudflare R2 config for backups
});

export const router = createUploadRouter(
  {
    productImages: uploadSchema({
      image: { maxSize: "4MB", maxCount: 10 },
    }),

    backups: uploadSchema({
      any: { maxSize: "1GB", maxCount: 1 },
    }),
  },
  {
    s3: primaryS3,
    providers: {
      backups: { s3: backupR2 },
    },
  }
);
```

## Middleware Integration

Add authentication, logging, and custom validation:

### Authentication Middleware

```typescript
export const router = createUploadRouter({
  privateUploads: uploadSchema({
    image: { maxSize: "4MB", maxCount: 5 },
  }).middleware(async ({ req }) => {
    const session = await getServerSession(req);

    if (!session?.user?.id) {
      throw new Error("Unauthorized");
    }

    return {
      userId: session.user.id,
      userRole: session.user.role,
    };
  }),

  publicUploads: uploadSchema({
    image: { maxSize: "1MB", maxCount: 1 },
  }), // No middleware = publicly accessible
});
```

### File Validation Middleware

```typescript
import { z } from "zod";

export const router = createUploadRouter({
  profilePicture: uploadSchema({
    image: { maxSize: "2MB", maxCount: 1 },
  }).middleware(async ({ req, files }) => {
    // Custom file validation
    for (const file of files) {
      if (file.name.includes("temp") || file.name.includes("test")) {
        throw new Error("Temporary files not allowed");
      }
    }

    const userId = await getUserId(req);
    return { userId };
  }),
});
```

### Metadata Enhancement

```typescript
export const router = createUploadRouter({
  documentUpload: uploadSchema({
    pdf: { maxSize: "10MB", maxCount: 1 },
  }).middleware(async ({ req }) => {
    const metadata = {
      uploadedAt: new Date().toISOString(),
      userAgent: req.headers.get("user-agent"),
      ip: req.headers.get("x-forwarded-for") || "unknown",
    };

    return { metadata };
  }),
});
```

## Lifecycle Hooks

Handle upload events for processing, notifications, and cleanup:

<TypeTable
  type={{
    onUploadStart: {
      description: "Called when upload begins",
      type: "(context) => void | Promise<void>",
    },
    onUploadProgress: {
      description: "Called during upload progress",
      type: "(context, progress) => void | Promise<void>",
    },
    onUploadComplete: {
      description: "Called when upload succeeds",
      type: "(context, result) => void | Promise<void>",
    },
    onUploadError: {
      description: "Called when upload fails",
      type: "(context, error) => void | Promise<void>",
    },
  }}
/>

```typescript
export const router = createUploadRouter({
  imageUpload: uploadSchema({
    image: { maxSize: "4MB", maxCount: 10 },
  })
    .onUploadComplete(async ({ files, metadata }) => {
      // Process uploaded images
      for (const file of files) {
        await generateThumbnail(file.url);
        await updateDatabase(file.key, metadata.userId);
      }
    })
    .onUploadError(async ({ error, metadata }) => {
      // Log errors and notify admins
      console.error("Upload failed:", error);
      await notifyAdmins(`Upload failed for user ${metadata.userId}`);
    }),
});
```

## Type Safety Features

### Router Type Export

Export your router type for end-to-end type safety:

```typescript title="lib/upload.ts"
export const router = createUploadRouter({
  // ... your configuration
});

export type AppRouter = typeof router;

// Extract individual endpoint types
export type ImageUploadType = AppRouter["imageUpload"];
export type DocumentUploadType = AppRouter["documentUpload"];
```

### Custom Context Types

Define custom context types for your middleware:

```typescript
interface CustomContext {
  userId: string;
  userRole: "admin" | "user" | "guest";
  organizationId?: string;
}

export const router = createUploadRouter({
  upload: uploadSchema({
    image: { maxSize: "4MB", maxCount: 5 },
  }).middleware(async ({ req }): Promise<CustomContext> => {
    // Your auth logic here
    return {
      userId: "user_123",
      userRole: "user",
    };
  }),
});
```

## Real-World Examples

### E-commerce Product Images

```typescript
export const ecommerceRouter = createUploadRouter({
  productImages: uploadSchema({
    image: {
      maxSize: "5MB",
      maxCount: 8,
      processing: {
        resize: { width: 1200, height: 1200 },
        formats: ["webp", "jpeg"],
        quality: 85,
      },
    },
  })
    .middleware(async ({ req }) => {
      const vendorId = await getVendorId(req);
      return { vendorId, category: "products" };
    })
    .onUploadComplete(async ({ files, metadata }) => {
      // Update product catalog
      await updateProductImages(metadata.vendorId, files);
    }),
});
```

### Document Management System

```typescript
export const docsRouter = createUploadRouter({
  contracts: uploadSchema({
    pdf: { maxSize: "25MB", maxCount: 1 },
  }).middleware(async ({ req }) => {
    const { userId, companyId } = await validateContractUpload(req);
    return { userId, companyId, confidential: true };
  }),

  proposals: uploadSchema({
    pdf: { maxSize: "50MB", maxCount: 3 },
    docx: { maxSize: "25MB", maxCount: 5 },
  }).middleware(async ({ req }) => {
    const { userId, projectId } = await validateProposalUpload(req);
    return { userId, projectId };
  }),
});
```

### Social Media Platform

```typescript
export const socialRouter = createUploadRouter({
  profilePicture: uploadSchema({
    image: {
      maxSize: "2MB",
      maxCount: 1,
      processing: {
        resize: { width: 400, height: 400 },
        format: "webp",
      },
    },
  }),

  postMedia: uploadSchema({
    image: { maxSize: "8MB", maxCount: 4 },
    video: { maxSize: "100MB", maxCount: 1 },
  }).middleware(async ({ req }) => {
    const userId = await authenticateUser(req);
    return { userId, postType: "media" };
  }),
});
```

## Security Best Practices

<Callout type="warning">
  **Important:** Always implement proper authentication and file validation in
  production environments.
</Callout>

### Content Type Validation

```typescript
export const router = createUploadRouter({
  secureUpload: uploadSchema({
    image: {
      maxSize: "4MB",
      maxCount: 5,
      mimeTypes: ["image/jpeg", "image/png", "image/webp"], // Explicit whitelist
    },
  }).middleware(async ({ req, files }) => {
    // Additional security checks
    for (const file of files) {
      // Validate file headers match content type
      const isValidImage = await validateImageFile(file);
      if (!isValidImage) {
        throw new Error("Invalid image file");
      }
    }

    return { userId: await getUserId(req) };
  }),
});
```

### Rate Limiting

```typescript
import { ratelimit } from "@/lib/ratelimit";

export const router = createUploadRouter({
  upload: uploadSchema({
    any: { maxSize: "10MB", maxCount: 3 },
  }).middleware(async ({ req }) => {
    const ip = req.headers.get("x-forwarded-for") || "unknown";

    const { success } = await ratelimit.limit(ip);
    if (!success) {
      throw new Error("Rate limit exceeded");
    }

    return { ip };
  }),
});
```

---

<Callout type="success">
  **Next Steps:** Now that you have your router configured, learn how to
  [configure your client](/docs/api/configuration/client-options) for the best
  developer experience.
</Callout>
